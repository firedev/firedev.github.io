<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Bottomless Ruby Hash</title>
  <meta name="description" content="The other day somebody asked if there is a way to blindly assign nested valuesto Ruby Hash without creating each key. Turns out there is, and it has anintere...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="http://firedev.com/posts/2015/bottomless-ruby-hash/">
  <link rel="alternate" type="application/rss+xml" title="firedev.com" href="http://firedev.com/feed.xml" />

  <meta content="width=device-width, initial-scale=1" name="viewport" />
  <link href="/images/favicon.png" rel="icon" />
  <link href="/images/favicon.png" rel="apple-touch-icon-precomposed" />
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.4.0/css/font-awesome.min.css" rel="stylesheet">

  <meta property="og:url" content="http://firedev.com/posts/2015/bottomless-ruby-hash/" />
  <meta property="og:title" content="Bottomless Ruby Hash" />
  <meta property="og:description" content="The other day somebody asked if there is a way to blindly assign nested values
to Ruby Hash without creating each key. Turns out there is, and it has an
interesting side-effect. Welcome Bottomless Hash.

" />
  <meta property="og:image" content="http://firedev.com/images/posts/bottomless_pit.jpg" />
</head>


  <body>

    <header class="site-header">
  <div class="container px2 mt2 mb2">
    <div class="clearfix mxn2">
      <div class="sm-col sm-col-3 px2">
        <h1 class="logo m0 relative">
          <a href="/" id="logo">
            <span class="hide">
              <span class="fire">
                fire
              </span>
              <span class="dev">
                dev
              </span>
              <span class="com">
                .com
              </span>
            </span>
            <img src="/images/logos/firedev.svg" alt="firedev.com" class="absolute bottom-0" />
            &nbsp;
          </a>
        </h1>
      </div>
      <nav class="sm-col sm-col-9 px2 mt2 py1">
        <div class="right mt2 p1 md-show">
          <a class="btn silver regular" href="/feed.xml">
            <i class="fa fa-rss"></i>
            RSS
          </a>
        </div>
        <h3>
          
            
          
            
              
                <a class="btn" href="/posts/">
                  Posts
                </a>
              
            
          
            
              
                <a class="btn" href="/projects/">
                  Projects
                </a>
              
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
            
          
        </h3>
      </nav>
    </div>
  </div>
</header>

    
<div class="main-image mb3" style="
background-image: url(/images/posts/bottomless_pit.jpg);
background-size: cover;
background-color: ;
background-position: ;
">
</div>


    <div class="container px2 mb4">
        

<header>
  <p>Oct 7, 2015</p>
  <h1 class="m0 mb2">Bottomless Ruby Hash</h1>
</header>


<div class="mb3">
  <article class="mb3">
    <p>The other day somebody asked if there is a way to blindly assign nested values
to Ruby Hash without creating each key. Turns out there is, and it has an
interesting side-effect. Welcome Bottomless Hash.</p>

<p>Let’s try assigning ‘through’ a key in plain old Ruby first.</p>

<p><code>ruby
params = {}
params[:world][:russia] = :moscow
=&gt; NoMethodError: undefined method `[]=' for nil:NilClass
</code></p>

<p>Okay, it doesn’t work like this. Fortunately Hashes in Ruby can be initialized
with a default value. First thing to try seems quite obvious. Let’s put an
empty hash as a default value.</p>

<p>```ruby
params = Hash.new({})
params[:world][:russia] = :moscow</p>

<p>params[:world]
=&gt; {:russia=&gt;:moscow}
```</p>

<p>Seems legit. But let’s dig a little deeper.</p>

<p>```ruby
params[:world][:thailand]=:bangkok</p>

<p>params
=&gt; {}
```</p>

<p>Why is it empty? Let’s add more stuff to it.</p>

<p>```ruby
params[:underworld]=:hell</p>

<p>params
=&gt; {:underworld=&gt;:hell}
```</p>

<p>What is going on? Some wicked magic? Not quite. First the <code>:world</code> key was initialized
with the same empty Hash that we put as a default value. It is easy to access still,
since the same Hash is returned when the key is empty. However now all our cities
are available in both worlds.</p>

<p>```ruby
params[:world][:thailand]
=&gt; :bangkok</p>

<p>params[:underworlds][:russia]
=&gt; :moscow
```</p>

<p>Okay, we got to fix it. To initialize new hash for values we need to pass a block.
Block accepts two variables - the <code>hash</code> itself and the <code>key</code> it was accessed with.
Lets just inject new empty hash as a value for the key.</p>

<p>```ruby
params = Hash.new do |hash, key|
  hash[key] = Hash.new
end</p>

<p>params[:world][:thailand]=:phuket</p>

<p>params
=&gt; {:world=&gt;{:thailand=&gt;:phuket}}
```</p>

<p>Amazing. Okay but what if we need to add another level?</p>

<p><code>ruby
params[:asia][:thailand][:bangkok] = :chao_praya
=&gt; NoMethodError: undefined method `[]=' for nil:NilClass
</code></p>

<p>Oh no, not again. What can we do? Let’s add another layer! So the nested Hash
could in turn create more hashes:</p>

<p>```ruby
params = Hash.new do |hash0, key0|
  hash0[key0] = Hash.new do |hash1, key1|
    hash1[key1] = Hash.new
  end
end</p>

<p>params[:asia][:thailand][:moscow] = :moscow_river
```
It works! But what if the rabbit hole is <em>even</em> deeper?</p>

<p><code>ruby
params[:asia][:thailand][:bangkok][:river] = :chao_praya
=&gt; NoMethodError: undefined method `[]=' for nil:NilClass
</code></p>

<p>Okay, have to solve this once and for all. Let’s throw some functional
programming in the mix and see where it takes us. What we need is a kind of
procedure that would return a new hash with the same procedure hidden inside
waiting for an empty key to come in.</p>

<p>What would such procedure look like? Quite familiar in fact. We just need to
pack it with <code>&amp;</code> symbol-to-proc pretzel to shove into Hash initializer.</p>

<p>```ruby
procedure = lambda do |hash, key|
  hash[key] = Hash.new(procedure)
end</p>

<p>params = Hash.new(&amp;procedure)
params[:russia][:moscow] = :moscow_river
params
=&gt; {:russia=&gt;{:moscow=&gt;:moscow_river}}
```</p>

<p>Okay, that part is solved, now lets tie it a little tighter so we don’t need to
create lambda beforehand. Ruby Hash sports <code>default_proc</code> method that can
be used to access the block hash was initialized with. Thank makes it super sweet,
thanks Pavel for pointing me on that.</p>

<p>```ruby
params = Hash.new { |h, k| h[k] = Hash.new(&amp;h.default_proc) }</p>

<p>params[:world][:thailand][:bangkok][:bangna]
params
=&gt; {:world=&gt;{:thailand=&gt;{:bangkok=&gt;{:bangna=&gt;{}}}}}
```</p>

<p>This is sweet, but what is the practical point of bottomless hash? Interesting
side-effect is that it never fails you when reading values.</p>

<p><code>ruby
params[:i][:dont][:know]
=&gt; {}
</code></p>

<p>And the beauty of this is that you can merge any hash with it to produce
a bottomless version. So you can blindly access the keys.</p>

<p>```ruby
unknown = { key: :value }
bottomless = params.merge other</p>

<p>bottomless[:missing][:value]
=&gt; {}
```</p>

<p>No matter how long the chain is, bottomless hash won’t raise an error. Okay, it returns
and empty hash instead of <code>nil</code>, which is truthy. But this can be checked with
<code>empty?</code> even in plain ruby.</p>

<p>As it was mentioned in comments we can encapsulated the behaviour into a Class that would
return an empty Bottomless hash or convert a given hash into a bottomless version:</p>

<p>```ruby
class BottomlessHash &lt; Hash
  def initialize
    super &amp;-&gt; h, k { h[k] = self.class.new }
  end</p>

<p>def self.from_hash(hash)
    new.merge(hash)
  end
end
```</p>

<p>And some tests for the good night sleep:</p>

<p>```ruby
class BottomlessHash &lt; Hash
  def initialize
    super &amp;-&gt; h, k { h[k] = self.class.new }
  end</p>

<p>def self.from_hash(hash)
    new.merge(hash)
  end
end</p>

<p>class Hash
  def bottomless
    BottomlessHash.from_hash(self)
  end
end</p>

<p>describe BottomlessHash do
  subject { described_class.new }</p>

<p>it ‘does not raise on missing key’ do
    expect do
      subject[:missing][:key]
    end.to_not raise_error
  end</p>

<p>it ‘returns an empty value on missing key’ do
    expect(subject[:missing][:key]).to be_empty
  end</p>

<p>it ‘stores and returns keys’ do
    subject[:existing][:key] = :value
    expect(subject[:existing][:key]).to eq :value
  end</p>

<p>describe ‘#from_hash’ do
    let (:hash) do
      { existing: { key: { value: :hello } } }
    end</p>

<pre><code>subject do
  described_class.from_hash(hash)
end

it 'returns old hash values' do
  expect(subject[:existing][:key][:value]).to eq :hello
end

it 'provides a bottomless version' do
  expect(subject[:missing][:key]).to be_empty
end

it 'stores and returns new values' do
  subject[:existing][:key] = :value
  expect(subject[:existing][:key]).to eq :value
end

it 'converts nested hashes as well' do
  expect do
    subject[:existing][:key][:missing]
  end.to_not raise_error
end   end end
</code></pre>

<p>```</p>

<p>And an ActiveSupport-like extension for the Hash class so you can call <code>.bottomless</code> on
any hash in the system. Thanks Patrick!</p>

<p><code>ruby
class Hash
  def bottomless
    BottomlessHash.from_hash(self)
  end
end
</code></p>

<p>Hope this little experiment might get useful for data processing or when dealing with unknown
nested structures from the outside world.</p>

<h3 id="links">Links</h3>
<p><i class="fa fa-file-o"></i> <a href="http://firedev.com/posts/2015/bottomless-ruby-hash">Bottomless Ruby Hash</a><br />
<i class="fa fa-file-o"></i> <a href="http://firedev.com/posts/2015/making-bottomless-hash-ruby-gem/">Making Bottomless Hash Ruby Gem</a><br />
<i class="fa fa-github"></i> Github <a href="https://github.com/firedev/bottomless_hash">firedev/bottomless_hash</a><br />
<i class="fa fa-github"></i> Gist <a href="https://gist.github.com/firedev/9de91e245f70c2e963e4">bottomless_hash.rb</a><br /></p>

  </article>

  <div class="mb3 lh25">
 

<a href="/ruby/" class="button bg-orange white lh1"> Ruby </a>

</div>


</div>
<div class="mt4">
<div class="clearfix mxn2 mb4">
  <div class="sm-col sm-col-3 px2">
    <img class="rounded" src="/images/me.jpg" alt="Hello!"/>
  </div>
  <div class="sm-col sm-col-6 px2">
    <h2 class="mt0 h1">
      Nick Ostrovsky
    </h2>
    <p>
      Full-stack designer. I like to keep things minimal and as simple as possible.
    </p>
    <p>
      Started years ago with a Sinclair Spectrum and has moved to user
      experience and interfaces since. Developed and contributed to projects
      for major brands such as L'Oreal, JTI and AB InBev among others. You can
      follow me on <a href="http://twitter.com/firedev">@firedev</a>
    </p>
    <p>
      Currently working as an independent contractor. Enjoying beautiful
      scenery of Phuket, Thailand with <a href="http://molokophuket.com">wife</a> and
      two <a href="http://anya.io">daughters</a>.
    </p>
  </div>
  <div class="sm-col sm-col-3 sm-show">
    <div class="ml2">
      <!-- <a class="p1 px2 white bg-green rounded mb1 inline-block" href="mailto:nick@firedev.com" -->
      <!-- title="Hey, I am looking for a team to join"><i class="fa fa-cog"></i> <b>Looking</b></a> -->
      <a class="p1 px2 block" href="http://github.com/firedev"><i class="fa fa-github"></i> Github</a>
      <a class="p1 px2 block" href="http://twitter.com/firedev"><i class="fa fa-twitter"></i> Twitter</a>
      <!--<a class="p1 px2 block" href="http://twitter.com/_dearapple"><i class="fa fa-twitter"></i>@_dearapple</a>-->
      <a class="p1 px2 block" href="http://stackoverflow.com/users/166484/nick"><i class="fa fa-stack-overflow"></i> StackOverflow</a>
      <a class="p1 px2 block" href="mailto:nick@firedev.com"><i class="fa fa-envelope"></i> Email Me</a>
    </div>
  </div>
</div>

</div>
<div id="disqus_thread"></div>
<script type="text/javascript">
/* * * CONFIGURATION VARIABLES * * */
var disqus_shortname = 'firedevcom';

/* * * DON'T EDIT BELOW THIS LINE * * */
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>

    </div>

    <footer>
    <div class="container px2 mt4 mb2 center">
        With <i class="fa fa-heart red"></i>
        <a href="http://firedev.com"><strong>firedev.com</strong></a>
    </div>
    <div class="container px2 mb4 center">
        <a class="muted" href="mailto:nick@firedev.com">Email me</a>
    </div>
</footer>

    <script src="/js/firedev.js"></script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-69016906-1', 'auto');
  ga('send', 'pageview');

</script>

  </body>

</html>
